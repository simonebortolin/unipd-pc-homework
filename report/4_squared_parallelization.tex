\section{Squared Parallelization}\label{squared-parallelization}

Our idea is to reduce synchronisation times between threads as much as possible and to always use a divide-and-conquer algorithm. 
It is based on the parallelization through inscribed squares in squares.


\begin{enumerate}
    \item First the input matrix is divided into \(h\) blocks of size \(s\).
    \item For each block a simplified version of Floyd-Warshall, i.e. \texttt{Floyd} from \cref{alg:Floyd} of \cref{alg:fw-blocked}, is run on each self-dependent cell in \(d[h{\twodots}h{+}b,h{\twodots}h{+}b]\) (\cref{alg:inner-square} of \cref{alg:fw-squared}) 
    \item Run the simplified \texttt{Floyd} on the row and column of the current block of dimension \(k\) as in \cref{fig:square-dependecies-thread} (\cref{alg:square-row-first} and \ref{alg:square-column-first} of \cref{alg:fw-squared}). (Optionally these steps can also be run in parallel)
    \item The remaining blocks are computed in parallel on other threads (\cref{alg:square-row} and \ref{alg:square-column} of \cref{alg:fw-squared}).
    \item Increase \(k\) by one and return to step 3 until \(\lfloor n/2b \rfloor\) is reached.
    \item Await until all threads have finished their execution to increment \(h\) and start again the computation of a new block.
\end{enumerate}
The algorithm is specifically illustrated in \cref{alg:fw-squared} and \cref{fig:square-algo}.
It is evident that this algorithm requires a very specific partition, i.e. it must generate an odd number of rows and columns. 
Despite this fictitious problem, it can be simply solved by adding fictitious data, for example, vertices disconnected from the complete graph.
\begin{figure}[htbp]
    \centering
    \begin{minipage}{\textwidth}
        \begin{algorithm}[H]
            \SetKwBlock{FDo}{do}{end}

            \SetKwFunction{FFloyd}{Floyd}
          
            \SetKwFunction{FThread}{Thread}

            \SetKwFunction{FAdd}{Add}
            
            \SetKwFunction{FJoin}{Join}

            \SetKwFunction{FSquaredBlocked}{Squared Floyd Warshall}
            \SetKwProg{Pn}{Function}{:}{\KwRet}
            \Pn{\FSquaredBlocked{\(d\)}}{
                let \(b\) number of partition


                \For{\(h \in [1{\twodots}n \operatorname{with} \operatorname{step} b]\)}{
                    \FFloyd{\(d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} \label{alg:inner-square}

                    
                    let \(t\) an empty thread list

                    \For{\(k \in [1{\twodots}\lfloor n/b/2 \rfloor]\)}{

                        \For{\(j \in [(h{\pm}s+n) \bmod n]\)}{ \label{alg:square-row-first}
                            \FFloyd{\(d[h{\twodots}h{+}b,j{\twodots}j{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                        }
                        \For{\(i \in [(h{\pm}s+n) \bmod n]\)}{ \label{alg:square-column-first}
                            \FFloyd{\(d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                        }
                        
                        \(t\).\FAdd{\FThread{ 
                            \FDo{
                                \For{\(j,i \in [(k{\pm}1+n) \bmod n] \times [((-k{\twodots}k)+n) \bmod n] \setminus 0\)}{ \label{alg:square-row}
                                    \FFloyd{\(d[i{\twodots}i{+}b,j{\twodots}j{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                                }
                                \For{\(i,j \in [(k{\pm}1+n) \bmod n] \times [((-k{+}1{\twodots}k{-}1)+n) \bmod n] \setminus 0\)}{ \label{alg:square-column}
                                    \FFloyd{\(d[i{\twodots}i{+}b,j{\twodots}j{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                                }
                            }
                        }}
                    }
                    \FJoin{\(t\)}
                }
            }
            \caption{Floyd-Warshall's squared parallel algorithm.}
            \label{alg:fw-squared}
        \end{algorithm}
    \end{minipage}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo}
        
        \caption{Graphical representation of the order of execution of the squared algorithm to respect dependencies. In dark green are the blocks to be executed before the lighter ones.}
        \label{fig:square-dependecies-algo}
    \end{subfigure}
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo_thread}
        
        \caption{Graphical representation of the subdivision of the functional execution: in dark green the only element that cannot be executed in parallel, in light green the elements that can be executed in parallel but in this algorithm are not by algorithm design, in white the blocks executed in parallel.}
        \label{fig:square-dependecies-thread}
    \end{subfigure}
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo_mod}
        
        \caption{Graphical representation of the circular array operation of our algorithm to optimise the execution of the algorithm even when our self-dependent block is not central: a mod is executed within the circular matrix to avoid wasting parallel executions.}
        \label{fig:square-dependecies-circular}
    \end{subfigure}
    \caption{Graphical representation of the squared Floyd Warshall algorithm: in the first illustration, sequential and parallel executions are described, in the second the subdivision over several threads and in the third the circular matrix solution.}
        \label{fig:square-algo}
\end{figure}

\FloatBarrier
