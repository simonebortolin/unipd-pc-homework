\section{Squared Parallelization}\label{squared-parallelization}

Our idea is to reduce synchronisation times between threads as much as possible and to always use a divide-and-conquer algorithm. 
It is based on the parallelization through inscribed squares in squares.

The main principle is that for each block of \(h\), a simplified \texttt{Floyd} is run on the block \(d[h{\twodots}h{+}b,h{\twodots}h{+}b]\) (\cref{alg:inner-square} of \cref{alg:fw-squared}) and after this let \(k=1\):
\begin{enumerate}
    \item Run the \texttt{Floyd} simplified on the central blocks of the 4 sides of the square of dimension \(k\) (\cref{alg:square-row-first} and \ref{alg:square-column-first} of \cref{alg:fw-squared}).
    \item Run on other thread \texttt{Floyd} simplified in the remaining blocks of the square of dimension \(k\) (\cref{alg:square-row} and \ref{alg:square-column} of \cref{alg:fw-squared}).
    \item Increase \(k\) by one and return to step 1 until \(\lfloor n/b/2 \rfloor\) is reached.
\end{enumerate}
The algorithm is specifically illustrated in \cref{alg:fw-squared} and \cref{fig:square-algo}.
It is evident that this algorithm requires a very specific partition, i.e. it must generate an odd number of rows and columns. 
Despite this fictitious problem, it can be simply solved by adding fictitious data, for example, vertices disconnected from the complete graph.
\begin{figure}[htbp]
    \centering
    \begin{minipage}{\textwidth}
        \begin{algorithm}[H]
            \SetKwBlock{FDo}{do}{end}

            \SetKwFunction{FFloyd}{Floyd}
          
            \SetKwFunction{FThread}{Thread}

            \SetKwFunction{FAdd}{Add}
            
            \SetKwFunction{FJoin}{Join}

            \SetKwFunction{FSquaredBlocked}{Squared Floyd Warshall}
            \SetKwProg{Pn}{Function}{:}{\KwRet}
            \Pn{\FSquaredBlocked{\(d\)}}{
                let \(b\) number of partition


                \For{\(h \in [1{\twodots}n \operatorname{with} \operatorname{step} b]\)}{
                    \FFloyd{\(d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} \label{alg:inner-square}

                    
                    let \(t\) an empty thread list

                    \For{\(k \in [1{\twodots}\lfloor n/b/2 \rfloor]\)}{

                        \For{\(j \in [(h{\pm}s+n) \bmod n]\)}{ \label{alg:square-row-first}
                            \FFloyd{\(d[h{\twodots}h{+}b,j{\twodots}j{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                        }
                        \For{\(i \in [(h{\pm}s+n) \bmod n]\)}{ \label{alg:square-column-first}
                            \FFloyd{\(d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,h{\twodots}h{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                        }
                        
                        \(t\).\FAdd{\FThread{ 
                            \FDo{
                                \For{\(j,i \in [(k{\pm}1+n) \bmod n] \times [((-k{\twodots}k)+n) \bmod n] \setminus 0\)}{ \label{alg:square-row}
                                    \FFloyd{\(d[i{\twodots}i{+}b,j{\twodots}j{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                                }
                                \For{\(i,j \in [(k{\pm}1+n) \bmod n] \times [((-k{+}1{\twodots}k{-}1)+n) \bmod n] \setminus 0\)}{ \label{alg:square-column}
                                    \FFloyd{\(d[i{\twodots}i{+}b,j{\twodots}j{+}b],d[i{\twodots}i{+}b,h{\twodots}h{+}b],d[h{\twodots}h{+}b,j{\twodots}j{+}b],pred[h{\twodots}h{+}b,h{\twodots}h{+}b]\)} 
                                }
                            }
                        }}
                    }
                    \FJoin{\(t\)}
                }
            }
            \caption{Floyd-Warshall's squared parallel algorithm.}
            \label{alg:fw-squared}
        \end{algorithm}
    \end{minipage}
\end{figure}

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo}
        
        \caption{Graphical representation of the order of execution of the squared algorithm to respect dependencies. In dark green are the blocks to be executed before the lighter ones.}
        \label{fig:square-dependecies-algo}
    \end{subfigure}
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo_thread}
        
        \caption{Graphical representation of the subdivision of the functional execution: in dark green the only element that cannot be executed in parallel, in light green the elements that can be executed in parallel but in this algorithm are not by algorithm design, in white the blocks executed in parallel.}
        \label{fig:square-dependecies-thread}
    \end{subfigure}
    \begin{subfigure}[t]{0.3\textwidth}
        \includegraphics[width=\textwidth]{media/square_dependencies_algo_mod}
        
        \caption{Graphical representation of the circular array operation of our algorithm to optimise the execution of the algorithm even when our self-dependent block is not central: a mod is executed within the circular matrix to avoid wasting parallel executions.}
        \label{fig:square-dependecies-circular}
    \end{subfigure}
    \caption{Graphical representation of the squared Floyd Warshall algorithm: in the first illustration, sequential and parallel executions are described, in the second the subdivision over several threads and in the third the circular matrix solution.}
        \label{fig:square-algo}
\end{figure}

\FloatBarrier